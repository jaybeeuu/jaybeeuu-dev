import fs from "node:fs/promises";
import { asError } from "@jaybeeuu/utilities";
import path from "node:path";
import postcss from "postcss";
import selectorParse from "postcss-selector-parser";
import type { Plugin, ResolvedConfig } from "vite";
import { diff as getDiff } from "jest-diff";

export interface CSSModuleTypeOptions {
  check?: boolean;
}

const isDir = async (dir: string): Promise<boolean> => {
  try {
    return (await fs.stat(dir)).isDirectory();
  } catch {
    return false;
  }
};

const isCSSSelectorValid = (selector: string): boolean => {
  try {
    selectorParse().processSync(selector);
    return true; // If no errors occurred, the selector is valid
  } catch (error) {
    console.error(
      `Invalid CSS selector: ${selector}: ${asError(error).message}`,
    );
    return false; // If an error occurred, the selector is not valid
  }
};

const getUniquesClassNames = async (fullPath: string): Promise<string[]> => {
  const css = await fs.readFile(fullPath, "utf8");
  const classNames = new Set<string>();
  const result = await postcss().process(css, {
    from: fullPath,
    to: fullPath.replace(".css", ".css.d.ts"),
  });

  result.root.walkRules((rule) => {
    if (!isCSSSelectorValid(rule.selector)) {
      return;
    }
    selectorParse((selectors) => {
      selectors.walkClasses((selector) => {
        classNames.add(selector.value);
      });
    }).processSync(rule.selector);
  });

  return [...classNames];
};

const kebabCaseToPascalCase = (cls: string): string => {
  const [firstWord, ...otherWords] = cls.split("-");
  return [
    firstWord,
    ...otherWords.map((word) => {
      const first = word.slice(0, 1);
      const rest = word.slice(1);
      return first.toUpperCase() + rest;
    }),
  ].join("");
};

const getFormattedTypeDeclaration = (classes: string[]): string =>
  [
    "// This file is automatically generated.",
    "// Do not manually edit this file!",
    "interface CssExports {",
    ...classes.map((cls) => `  "${kebabCaseToPascalCase(cls)}": string;`),
    "}",
    "export const cssExports: CssExports;",
    "export default cssExports;",
  ].join("\n");

const getDeclarationFilePath = (fullPath: string): string =>
  fullPath.replace(".module.css", ".module.css.d.ts");

const createDeclarationFile = async (fullPath: string): Promise<void> => {
  const uniquesClassName = await getUniquesClassNames(fullPath);
  const formattedDeclaration = getFormattedTypeDeclaration(uniquesClassName);

  const declarationPath = getDeclarationFilePath(fullPath);
  try {
    await fs.writeFile(declarationPath, formattedDeclaration);
  } catch (err) {
    console.error(`Error writing file ${declarationPath}:`, err);
  }
};

const checkDeclarationFile = async (fullPath: string): Promise<void> => {
  const uniquesClassName = await getUniquesClassNames(fullPath);
  const expectedDeclaration = getFormattedTypeDeclaration(uniquesClassName);

  const declarationPath = getDeclarationFilePath(fullPath);
  const actualDeclaration = await fs.readFile(declarationPath, "utf8");

  if (expectedDeclaration !== actualDeclaration) {
    const diff = getDiff(expectedDeclaration, actualDeclaration);
    throw new Error(
      `Declaration file ${declarationPath} does not match the expected compilation of ${fullPath}. You must recompile and commit the result.\n\n${diff}\n`,
    );
  }
};

const processFile = async (
  filePath: string,
  options: Required<CSSModuleTypeOptions>,
): Promise<void> => {
  if (!filePath.endsWith(".module.css")) {
    return;
  }
  return options.check
    ? checkDeclarationFile(filePath)
    : createDeclarationFile(filePath);
};

const processDirectory = async (
  directoryPath: string,
  options: Required<CSSModuleTypeOptions>,
): Promise<void> => {
  if (await isDir(directoryPath)) {
    const dirs = await fs.readdir(directoryPath);

    await Promise.all(
      dirs.map(async (dir) => {
        const fullPath = path.join(directoryPath, dir);

        if (await isDir(fullPath)) {
          await processDirectory(fullPath, options);
        } else {
          await processFile(fullPath, options);
        }
      }),
    );

    return;
  }

  if (directoryPath.endsWith(".module.css")) {
    await createDeclarationFile(directoryPath);
  }
};

const resolveFullPath = (config: ResolvedConfig, file: string): string =>
  path.join(config.build.outDir, path.relative(config.publicDir, file));

const defaultOptions = (
  userOptions?: CSSModuleTypeOptions,
): Required<CSSModuleTypeOptions> => ({
  check: process.env.CI === "true",
  ...userOptions,
});

export const cssModuleTypes = (options?: CSSModuleTypeOptions): Plugin => {
  const defaultedOptions = defaultOptions(options);
  return {
    name: "css-module-type",
    configureServer() {
      const directory = path.join(process.cwd(), "./src");
      void processDirectory(directory, defaultedOptions);
    },

    async generateBundle() {
      const directory = path.join(process.cwd(), "./src");
      await processDirectory(directory, defaultedOptions);
    },

    async handleHotUpdate({ server: { config }, file }): Promise<void> {
      const fullPath = resolveFullPath(config, file);
      await processFile(fullPath, defaultedOptions);
    },
  };
};
